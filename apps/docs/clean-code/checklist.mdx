---
title: "Code Review Guidelines"
description: "Comprehensive checklist for reviewing code in TurboStack to ensure quality, consistency, and security."
icon: "list-check"
---

# Code Review Guidelines

This document serves as a comprehensive checklist for reviewing code in the TurboStack project. It is designed to ensure code quality, consistency, security, and architectural integrity across the monorepo.

Use this checklist before submitting a Pull Request (PR) or during the code review process.

<Note>
  These guidelines are enforced to maintain the high standards of the TurboStack
  architecture. Adhering to them ensures a smooth development process and a
  robust production environment.
</Note>

## üß† General (Stack Agnostic)

### Core Principles

- [ ] **Single Responsibility Principle (SRP)**: Does each file, function, and service perform a single, well-defined task?
- [ ] **Naming Conventions**: Is the naming clear and domain-specific? (e.g., `userSettings`, `billingCycle`, `subscriptionPlan` instead of generic names like `data`, `config`).
- [ ] **Dead Code**: Are there any unused exports, variables, or imports that should be removed?
- [ ] **Side Effects**: Are side effects (especially in server actions and hooks) explicit and managed correctly?
- [ ] **Environment Variables**: Are env variables handled securely? (e.g., `process.env` should not be leaked to the client directly; use validated config via `@t3-oss/env-nextjs`).
- [ ] **Magic Numbers/Strings**: Are magic strings and numbers replaced with enums or constants?
- [ ] **Error Handling**: Is there robust error handling, or does the code only cover the "happy path"?
- [ ] **Logging**: Is the log level appropriate? (No `console.log` in production; use structured logging like `pino`).

---

## ‚öõÔ∏è Frontend ‚Äì Next.js (App Router)

### 1Ô∏è‚É£ Architecture & Folder Structure

- [ ] **Routing vs. Logic**: Does `app/` strictly handle routing and composition?
- [ ] **Business Logic Placement**:
  - ‚ùå Business logic in `page.tsx`
  - ‚úÖ Logic moved to `features/`, `services/`, or `hooks/`
- [ ] **Component Classification**:
  - `components/ui`: Dumb/presentational components (shadcn/ui)
  - `components/features`: Domain-aware components
- [ ] **Responsibility**: Page components should orchestrate; UI components should render.

### 2Ô∏è‚É£ Server / Client Boundary

- [ ] **"use client" Usage**: Is `"use client"` minimized and used only when necessary?
- [ ] **Server Components**: Ensure no client-side specific APIs (e.g., `useEffect`, `window`, `localStorage`) are used in Server Components.
- [ ] **Client Components**: Avoid heavy data fetching directly in Client Components unless necessary.
- [ ] **Data Fetching Strategy**: Fetch data on the server, manage state on the client where appropriate.

### 3Ô∏è‚É£ Data Fetching

- [ ] **Caching Strategy**: Are fetch cache settings (`no-store`, `revalidate`) explicitly defined?
- [ ] **Service Layer**:
  - ‚ùå Fetching the same endpoint in multiple places
  - ‚úÖ Using a unified service layer (`apps/web/services`) for API calls
- [ ] **Parallel Fetching**: Are independent data fetches executed in parallel (e.g., using `Promise.all`)?

### 4Ô∏è‚É£ Performance

- [ ] **Re-renders**: Are unnecessary re-renders avoided?
- [ ] **Memoization**: Are `useMemo` and `useCallback` used effectively (not just reflexively)?
- [ ] **Large Lists**: Is pagination or virtualization used for large datasets?
- [ ] **Image Optimization**: Is `next/image` used for images?
- [ ] **Bundle Size**: Are there any heavy libraries bloating the bundle?

### 5Ô∏è‚É£ Form & Validation

- [ ] **Validation Layer**:
  - ‚ùå Validation logic only in the frontend
  - ‚úÖ Shared Zod schemas (`@repo/validations`) used for both frontend and backend
- [ ] **User Feedback**: Are validation errors and success states clearly communicated to the user (e.g., via `sonner` toast)?
- [ ] **Optimistic UI**: If used, is there a rollback mechanism for failed operations?

### 6Ô∏è‚É£ DX & Maintainability

- [ ] **Reusable Hooks**: Are custom hooks truly reusable and logic-focused?
  - ‚ùå Hook rendering UI
  - ‚úÖ Hook managing logic only
- [ ] **Type Safety**:
  - ‚ùå Avoid `any` and `as unknown as`
  - ‚úÖ Ensure API responses are fully type-safe via shared types or Eden Treaty

---

## ü¶ä Backend ‚Äì Elysia.js

### 1Ô∏è‚É£ Route Structure

- [ ] **Logic Separation**:
  - ‚ùå Routes containing business logic
  - ‚úÖ Routes strictly handling HTTP request/response orchestration, delegating logic to `services/`
- [ ] **Layered Architecture**: Is there a clear separation between Route Handlers and Services?

### 2Ô∏è‚É£ Elysia Best Practices

- [ ] **Schema Validation**: Are `t.Object`, `t.Enum`, and other TypeBox schemas used for validation in routes?
- [ ] **Schema Definition**: Are request/response schemas explicitly defined for Swagger documentation?
- [ ] **Shared Schemas**: Are schemas shared with the frontend for consistency?
- [ ] **Schema Role**: Treat schemas as validation, documentation, and type safety mechanisms.

### 3Ô∏è‚É£ Auth & Security

- [ ] **Auth Implementation**:
  - ‚ùå Scattered auth checks in routes
  - ‚úÖ Centralized middleware or `derive` usage for session injection
- [ ] **Role Checking**: Is `requireAdmin` or similar helpers used for role-based access control?
- [ ] **Error Security**:
  - ‚ùå Leaking database errors (e.g., "User not found in DB query")
  - ‚úÖ Returning standardized errors (e.g., "Unauthorized", "Not Found")

### 4Ô∏è‚É£ Error Handling

- [ ] **Global Handling**: Is the global `.onError` handler used for standardizing responses?
- [ ] **Custom Errors**: Are custom error types (`AppError`) used?
  ```typescript
  throw new AppError("USER_NOT_FOUND", "User not found", 404);
  ```
- [ ] **Status Codes**: Are HTTP status codes used consistently and correctly (e.g., 400 for validation, 401 for auth, 403 for permission)?

### 5Ô∏è‚É£ Database / ORM

- [ ] **N+1 Queries**: Are potential N+1 query issues identified and resolved (e.g., using `include` correctly)?
- [ ] **Transactions**: Are database transactions used where atomicity is required?
- [ ] **Pagination**:
  - ‚ùå Fetching all records (`findMany()` without limits)
  - ‚úÖ Using `take`, `skip` based on pagination params
- [ ] **Indexing**: Are database indexes applied to frequently queried fields (in `schema.prisma`)?

### 6Ô∏è‚É£ Performance

- [ ] **Heavy Operations**: Are heavy computations (e.g., image processing) handled efficiently?
- [ ] **Response Size**: Is the response payload optimized (no unnecessary data)?
- [ ] **Await Chains**: Are unnecessary sequential `await` calls avoided where `Promise.all` could be used?

---

## üîó Frontend ‚Üî Backend Consistency

- [ ] **Response Shape**:
  - ‚ùå Inconsistent response formats
  - ‚úÖ Standardized response structure (`ApiResponse<T>`):
    ```typescript
    {
      success: boolean;
      data?: T;
      message?: string;
      error?: string;
    }
    ```
- [ ] **Shared Types**: Is there a shared `@repo/types` or validation package used by both ends?
- [ ] **Breaking Changes**: Does the type system catch breaking changes across the boundary?

---

## üö© Red Flags (Immediate Changes Required)

- [ ] **Effect Fetching**: `useEffect` containing direct `fetch` calls without a robust strategy (use Service layer).
- [ ] **Direct DB Access**: API routes accessing the database directly instead of through a service.
- [ ] **Logic in Pages**: Next.js pages containing complex business logic.
- [ ] **Massive Components**: Components exceeding 500 lines of code.
- [ ] **"Refactor Later"**: Comments promising future refactoring ("TODO: fix later") without immediate plans.
